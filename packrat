#!/usr/bin/perl

# Packrat is a tool that locally archives images that have been saved on reddit.com, liked on tumblr.com, or bookmarked on del.icio.us. Packrat supports multiple accounts on each of these sites. 

# You can find the latest vesion of packrat at https://github.com/paulburton0/packrat. If you have ideas or run across bugs, please report them in the GitHub issue tracker.

my $MODULE_ERROR;

# Include perl modules
eval{
    require JSON::XS; 		# Used for processing JSON results received from web apis and for reading and writing the .packrat.conf file.
    JSON::XS->import();
};

if($@){
    $MODULE_ERROR .= "The JSON::XS module is not installed. Please install it before running packrat.\n";
}

eval{
    require XML::Simple;	# Used to parse the result received when querying del.icio.us for new bookmarks.
    XML::Simple->import();
};

if($@){
    $MODULE_ERROR .= "\nThe XML::Simple module is not installed. Please install it before running packrat.\n";
;
}

eval{
    require LWP::UserAgent;	# Used to fetch JSON from apis and download images.
    LWP::UserAgent->import();
};

if($@){
    $MODULE_ERROR .= "\nThe LWP:UserAgent module is not installed. Please install it before running packrat.\n";
}

eval{
    require OAuth::Consumer;# Used to fetch JSON from tumblr.
    OAuth::Consumer->import();
};

if($@){
    $MODULE_ERROR .= "\nThe OAuth::Consumer module is not installed. Please install it before running packrat.\n";
}

eval{
    require File::Basename;	# Used to parse the filename, extension, and the rest of the URI from URLs.
    File::Basename->import();
};

if($@){
    $MODULE_ERROR .= "\nThe File::Basename module is not installed. Please install it before running packrat.\n";
}

eval{
    require File::Path; # Used to create directory trees.
    File::Path->import(make_path);
};

if($@){
    $MODULE_ERROR .= "\nThe File::Path module is not installed. Please install it before running packrat.\n";
}

eval{
    require File::Slurp;	# Used to read the .packrat.conf file.
    File::Slurp->import();
};

if($@){
    $MODULE_ERROR .= "\nThe File::Slurp module is not installed. Please install it before running packrat.\n";
}

eval{
    require DateTime;		# Used to parse and create date/time strings and perform date/time arithemtic when working with the del.icio.us api.
    DateTime->import();
};

if($@){
    $MODULE_ERROR .= "\nThe DateTime module is not installed. Please install it before running packrat.\n";
}

eval{
    require Getopt::Std;    # Used to process command line options.
    Getopt::Std->import();
};

if($@){
    $MODULE_ERROR .= "\nThe Getopt::Std module is not installed. Please install it before running packrat.\n";
}

eval{
    require Browser::Open;
    Browser::Open->import(open_browser_cmd, open_browser);
};

if($@){
    $MODULE_ERROR .= "\nThe Browser::Open module is not installed. Please install it before running packrat.\n";
}

if($MODULE_ERROR){
    print "\n$MODULE_ERROR\n";
    exit;
}

use Env qw(HOME USERPROFILE);	# Used to retreive the $HOME environment variable.

use strict;

our($opt_q, $opt_s, $opt_r, $opt_c, $opt_h);


# Constants that should be available in the broadest scope possible.
my $VERSION = '0.1';
my $USERAGENT = 'Packrat Image Archiver/' . $VERSION;
my $CONF_UPDATE = 0;
my $CONF;
my $DESTINATION;
my $NONIMAGEFILE;
my $FAILEDURLS;
my $IMGUR_ID;
my $TRACK;
my $TRACK_FILE;
my @SUFFIXES = ('jpeg', 'jpg', 'png', 'gif', 'bmp', 'tif', 'tiff'); # The list of image extensions we will be saving.
my $BROWSER_CMD = open_browser_cmd();
my $DIR_SEPARATOR = '/';

unless($ENV{"HOME"}){
    $HOME = $ENV{"USERPROFILE"};
    $DIR_SEPARATOR = '\\';
}

my $conf_file = $HOME . $DIR_SEPARATOR . ".packrat.conf";

if(-e $conf_file){
	my $configuration = read_file($conf_file);
	$CONF = JSON::XS->new->decode($configuration);

# Assign constants from the configuration file.
	$DESTINATION = $CONF->{'destination'};	 # The detination where downloaded images will be saved.
	$NONIMAGEFILE = $CONF->{'nonimage_file'}; # The file where URLs that are not direct links to images will be saved.
	$FAILEDURLS = $CONF->{'failed_urls_file'};# The file where URLs that cannot be downloaded will be saved.
	$IMGUR_ID = $CONF->{'imgur_auth_id'};	 # The imgur authentication ID (obtained from imgur when an application is registered).
}

# The track file is a json file that packrat creates and maintains.
# It contains the information that packrat needs to keep track of which 
# posts have been fetched and which are new.
$TRACK_FILE = $CONF->{'track_file'};

if(-e $TRACK_FILE){
	my $tracking = read_file($TRACK_FILE);
	$TRACK = JSON::XS->new->decode($tracking);
}

$Getopt::Std::STANDARD_HELP_VERSION = 1;

# The HELP_MESSAGE() subroutine prints the usage and options of packrat and exits.
sub HELP_MESSAGE{
    print "\nPackrat archives images from your Reddit saved links, del.icio.us bookmarks, and Tumblr likes.\n\n";
    print "Usage:\n";
    print "packrat\n";
    print "packrat -r\n";
    print "packrat -sc " . $DIR_SEPARATOR . "path" . $DIR_SEPARATOR . "to" . $DIR_SEPARATOR . "conffile.conf\n\n";
    print "Options\n";
    print "q\tSupresses the normal \"Checking\" and \"Downloading\" messages that normally print when packrat is running. Errors (such as local file access errors or download failures) are still printed.\n";
    print "s\tPackrat runs completely silently. No errors or status messages are displayed at all.\n";
    print "r\tForces the first-run configuration assistant to run.\n";
    print "c\tSpecifies the configuration file to use. This option takes an argument in the form of a path to a configuration file.\n\n";
    exit;
}

# The check_env() subroutine does a basic check of the environment to make sure packrat can run without any major errors.
sub check_env{
	# Check whether the detination directory is writeable.
	if (!-w $DESTINATION){
        if(!$opt_s){
            print "Cannot write to $DESTINATION. Exiting.\n";
        }
        exit 0;
	}

	# If the destination does not exist, create it.
	if (!-e $DESTINATION){
        
        if(!$opt_s){
            print "$DESTINATION does not exist. Creating it.\n";
        }

		make_path $DESTINATION || print "Cannot create $DESTINATION: $!\n" unless $opt_s && exit 0;

	}
}

# The first_run() subroutine walks the user through setting up packrat's
# settings as well as authorizing packrat to access online accounts.
sub first_run{

	print "\nWelcome to packrat. Let's get some configuration details\n";
	print "so that packrat will work for you.\n";

    print "\nWhere do you want to save image files that packrat downloads? [" .$HOME . $DIR_SEPARATOR . "packrat] ";
    $DESTINATION = <STDIN>;
    
    chomp($DESTINATION);

    if(!$DESTINATION){
        $DESTINATION = $HOME . $DIR_SEPARATOR . "packrat";
    }

    $CONF->{'destination'} = $DESTINATION;

    mkdir $DESTINATION || print "Cannot create $DESTINATION: $!\n" && exit;

    if(!-e $HOME . $DIR_SEPARATOR . ".packrat"){
        mkdir $HOME . $DIR_SEPARATOR . ".packrat" || print "Cannot create directory " . $HOME . $DIR_SEPARATOR . ".packrat: $!\n" && exit;
    }

    print "\nWhere should packrat save URLs that aren't direct image links? [" . $HOME . $DIR_SEPARATOR . ".packrat" . $DIR_SEPARATOR . "nonimages] ";

    $NONIMAGEFILE = <STDIN>;
    chomp($NONIMAGEFILE);

    if(!$NONIMAGEFILE){
        $NONIMAGEFILE = $HOME . $DIR_SEPARATOR . ".packrat" . $DIR_SEPARATOR . "nonimages";
    }

    $CONF->{'nonimage_file'} = $NONIMAGEFILE;

    my($filename, $directory) = fileparse($NONIMAGEFILE);

    $FAILEDURLS = $directory . 'failedurls'; 

    $CONF->{'failed_urls_file'} = $FAILEDURLS;

    my($filename, $directory) = fileparse($NONIMAGEFILE);

    $TRACK_FILE = $directory . 'packrat.track'; 

    $CONF->{'track_file'} = $TRACK_FILE;

    my $browser_ok;

    if($BROWSER_CMD){
        $browser_ok = open_browser('https://api.imgur.com/oauth2/addclient');

        if($browser_ok == 0){

            print "\nYour browser should open to https://api.imgur.com/oauth2/addclient. Log on to imgur.com and add an application. For Authorization Type, choose \"Anonymous usage without user authentication\". Record the Client ID that your application is assigned here. \nJust leave this plank if you don't want to use imgur.\n";
        }
    }
    
    elsif(!$BROWSER_CMD || $browser_ok != 0){
        print "\nLog on to http://imgur.com, then navigate to https://api.imgur.com/oauth2/addclient and add an application. For Authorization Type, choose \"Anonymous usage without user authentication\". Record the Client ID that your application is assigned here.\nJust leave this blank if you don't want to use imgur.\n";
    }

    print "Imgur.com Client ID: ";
    $IMGUR_ID = <STDIN>;
    chomp($IMGUR_ID);

    if($IMGUR_ID eq ''){
        $IMGUR_ID = 'disabled';
    }

    $CONF->{'imgur_auth_id'} = $IMGUR_ID;

    add_tumblr();
    add_delicious();
    add_reddit();

	my $new_conf = JSON::XS->new->pretty(1)->encode($CONF);
	open(CONFIGURATION, '>', $conf_file) || print "Cannot write configuration to $conf_file: $!\n" && exit;
	print CONFIGURATION $new_conf;
	close CONFIGURATION;
}

# add_tumbr() sets up OAuth access to one or more tumblr accounts.
sub add_tumblr{

	my $tumblr_accounts = [];
	print "\nIt looks like you've never added a tumblr account to packrat.\n";
	print "Follow these instructions to add one or more accounts now.\n";
	print "Do you want to add a tumblr account? [Y/n] ";

	ADD_TUMBLR:{
		my $add_tumblr = <STDIN>;
		chomp $add_tumblr;

		if($add_tumblr =~ /^n$/i){
			return;
		}
		elsif($add_tumblr !~ /^(y|n)$/i && $add_tumblr != ''){
			print "Please type 'y' or 'n' ";
			redo ADD_TUMBLR;
		}
	}

	ADDACCOUNT:{

		my $account = {};

		my $request_token_url = 'http://www.tumblr.com/oauth/request_token';
		my $authorize_url = 'http://www.tumblr.com/oauth/authorize';
		my $access_token_url = 'http://www.tumblr.com/oauth/access_token';

		print "\ntumblr username: ";
		my $username = <STDIN>;
		chomp $username;

		$account->{'username'} = lc $username;

        my $browser_ok;

        if($BROWSER_CMD){
            $browser_ok = open_browser('http://www.tumblr.com/oauth/apps');

            if($browser_ok == 0){

                print "\nYour browser should open to http://www.tumblr.com/oauth/apps. Click 'Allow' to enable packrat to access your tumblr account\n";
            }
        }
        
        elsif(!$BROWSER_CMD || $browser_ok != 0){
            print "\nLog on to tumblr.com and go to http://www.tumblr.com/oauth/apps\n";
            print "Register a new application and add the details requested below.\n";
        }

		print "OAuth Consumer Key: ";
		my $consumer_key = <STDIN>;
		chomp $consumer_key;

		$account->{'consumer_key'} = $consumer_key;

		print "Secret Key: ";
		my $secret_key = <STDIN>;
		chomp $secret_key;

		$account->{'consumer_secret'} = $secret_key;

		my $ua = OAuth::Consumer->new(
			 oauth_consumer_key => $consumer_key,
			 oauth_consumer_secret => $secret_key,
			 oauth_request_token_url => $request_token_url,
			 oauth_authorize_url => $authorize_url,
			 oauth_access_token_url => $access_token_url
		);

		my $verifier_url = eval{$ua->get_request_token()};

        if(!$verifier_url){
            ANOTHER:{
                print "\nThere was a problem adding that account.\n";
                print "\nWould you like to add another tumblr account? [Y/n] ";
                my $ans = <STDIN>;
                chomp($ans);

                if($ans =~ /^y$/i || $ans eq ''){
                    redo ADDACCOUNT;
                }
                elsif($ans =~ /^n$/i){
                    $CONF->{'services'}->{'tumblr'} = $tumblr_accounts;
                    $CONF_UPDATE = 1;
                    return;
                }
                else{
                    print "Please type 'y' or 'n' ";
                    redo ANOTHER;
                }
            }
        }

        if($BROWSER_CMD){
            my $browser_ok = open_browser($verifier_url);

            if($browser_ok == 0){

                print "\nYour browser should open to $verifier_url. Click 'Allow' to enable packrat to access your tumblr account.\n";
            }
        }
        
        elsif(!$BROWSER_CMD || $browser_ok != 0){
            print "Paste this URL into your browser's address bar. Click 'Allow' to enable packrat to access your tumblr account:\n";
            print "$verifier_url\n";
        }

		my ($token, $secret) = eval{$ua->get_access_token()};

        if(!$token || !$secret){
            ANOTHER:{
                print "\nThere was a problem adding that account.\n";
                print "\nWould you like to add another tumblr account? [Y/n] ";
                my $ans = <STDIN>;
                chomp($ans);

                if($ans =~ /^y$/i || $ans eq ''){
                    redo ADDACCOUNT;
                }
                elsif($ans =~ /^n$/i){
                    $CONF->{'services'}->{'tumblr'} = $tumblr_accounts;
                    $CONF_UPDATE = 1;
                    return;
                }
                else{
                    print "Please type 'y' or 'n' ";
                    redo ANOTHER;
                }
            }
        }

		$account->{'token_key'} = $token;
		$account->{'token_secret'} = $secret;

		push($tumblr_accounts, $account);

		print "Packrat is now authorized to access your \"$username\" tumblr account.\n";

		ANOTHER:{
			print "\nWould you like to add another tumblr account? [Y/n] ";
			my $ans = <STDIN>;
			chomp($ans);

			if($ans =~ /^y$/i || $ans eq ''){
				redo ADDACCOUNT;
			}
			elsif($ans =~ /^n$/i){
				$CONF->{'services'}->{'tumblr'} = $tumblr_accounts;
				$CONF_UPDATE = 1;
				return;
			}
			else{
				print "Please type 'y' or 'n' ";
				redo ANOTHER;
			}
		}
	}
}

# add_delicious() sets up access to one or more del.icio.us accounts.
sub add_delicious{

	my $delicious_accounts = [];

	print "\nIt looks like you've never added a delicious account to packrat.\n";
	print "Follow these instructions to add one or more accounts now.\n";
	print "Do you want to add a delicious account? [Y/n] ";

	ADD_DELICIOUS:{
		my $add_delicious = <STDIN>;
		chomp $add_delicious;

		if($add_delicious =~ /^n$/i){
			return;
		}
		elsif($add_delicious !~ /^(y|n)$/i && $add_delicious != ''){
			print "Please type 'y' or 'n' ";
			redo ADD_DELICIOUS;
		}
	}


	ADDACCOUNT:{

		my $account = {};

		print "\ndelicious username: ";
		my $username = <STDIN>;
		chomp $username;

		$account->{'username'} = lc $username;

		print "delicious password: ";
		my $password = <STDIN>;
		chomp $password;

		$account->{'password'} = $password;

		push($delicious_accounts, $account);

		print "Packrat is now authorized to access your \"$username\" delicious account.\n";

		ANOTHER:{
			print "\nWould you like to add another delicious account? [Y/n] ";
			my $ans = <STDIN>;
			chomp($ans);

			if($ans =~ /^y$/i || $ans eq ''){
				redo ADDACCOUNT;
			}
			elsif($ans =~ /^n$/i){
				$CONF->{'services'}->{'delicious'} = $delicious_accounts;
				$CONF_UPDATE = 1;
				return;
			}
			else{
				print "Please type 'y' or 'n' ";
				redo ANOTHER;
			}
		}
	}
}

# add_reddit() sets up access to one or more reddit accounts.
sub add_reddit{

	my $reddit_accounts = [];
		
	print "\nIt looks like you've never added a reddit account to packrat.\n";
	print "Follow these instructions to add one or more accounts now.\n";
	print "Do you want to add a reddit account? [Y/n] ";

	ADD_REDDIT:{
		my $add_reddit = <STDIN>;
		chomp $add_reddit;

		if($add_reddit =~ /^n$/i){
			return;
		}
		elsif($add_reddit !~ /^(y|n)$/i || $add_reddit != ''){
			print "Please type 'y' or 'n' ";
			redo ADD_REDDIT;
		}
	}

	ADDACCOUNT:{

		my $account = {};

		print "\nreddit username: ";
		my $username = <STDIN>;
		chomp $username;

		$account->{'username'} = lc $username;

        my $browser_ok;

        if($BROWSER_CMD){
            $browser_ok = open_browser('https://ssl.reddit.com/prefs/feeds/');

            if($browser_ok == 0){

                print "\nYour browser should open to https://ssl.reddit.com/prefs/feeds/. Make sure you're logged on with the Reddit account you want to add to packrat. In order to access the feed URL, you need to select \"enable private RSS feeds\" in the \"content options\" section on the \"Options\" tab of your Reddit account preferences.\n";
            }
        }
        
        elsif(!$BROWSER_CMD || $browser_ok != 0){
            print "Log on to reddit.com and navigate to https://ssl.reddit.com/prefs/feeds/\n";
        }


		print "Locate the JSON button for \"your saved links\", copy the link, and paste it here.\n";
		print "Saved link URL: ";
		my $rssurl = <STDIN>;
		chomp $rssurl;

		$account->{'rss_url'} = $rssurl;

		push($reddit_accounts, $account);

		print "Packrat is now authorized to access your \"$username\" reddit account.\n";

		ANOTHER:{
			print "\nWould you like to add another reddit account? [Y/n] ";
			my $ans = <STDIN>;
			chomp($ans);

			if($ans =~ /^y$/i || $ans eq ''){
				redo ADDACCOUNT;
			}
			elsif($ans =~ /^n$/i){
				$CONF->{'services'}->{'reddit'} = $reddit_accounts;
				$CONF_UPDATE = 1;
				return;
			}
			else{
				print "Please type 'y' or 'n' ";
				redo ANOTHER;
			}
		}
	}
}

# The add_nonimage_url() subroutine appends a URL to the NONIMAGEFILE (a text file) if it is not a direct link to an image.
sub add_nonimage_url{
	my $url = shift;

	open(NONIMAGES, '>>', $NONIMAGEFILE) || print "Cannot write to $NONIMAGEFILE: $!\n" unless $opt_s && return;
	print NONIMAGES $url . "\n";
	close NONIMAGES;
}

# The randomstring() subroutine generates a 10-character string of pseudo-random alpha characters. It is used by the filename_check() subroutine to ensure that new files don't overwrite existing files with the same name.
sub randomstring{
	my @randstring = map { (q(a)..q(z))[rand(26)] } 1 .. 10;
	my $rand;
	foreach my $thing (@randstring){
		$rand .= $thing;
	}
	return $rand;
}

# The filename_check() subroutine checks whether a filename exists in the destination, and if so it appends a pseudo-random string to the filename.
sub filename_check{
	my $oldname = shift;

	if (-e $DESTINATION . $DIR_SEPARATOR . $oldname) {
		CHECK:{
			my $randstring = randomstring();
			my ($fn, $path, $suffix) = fileparse($oldname, @SUFFIXES);
			my $newname = "$fn$randstring.$suffix";
			if (-e $DESTINATION . $DIR_SEPARATOR . $newname){ # Check whether the newly generated filename exists
				$oldname = $newname;
				redo CHECK; # If is does exist, go back to the beginning of the CHECK block and re-append a new pseudo-random string.
			}
		return $newname;
		}
	}else{
		return $oldname;
	}
}

# The get_imgur_album() subroutine takes a URL for an imgur album (e.g. http://imgur.com/a/xyz). It uses the imgur api to retrive the details of the album, then downloads the images in the album.
sub get_imgur_album{

	if($IMGUR_ID eq 'disabled'){
		return;
	}

	my $url = shift;

	if(!$opt_q && !$opt_s){
        print "Getting imgur album $url\n";
    }

	my($gallery_id) = $url =~ /^.*imgur\.com\/a\/(.*)$/i; # The album ID is the unique identifier for each album.

	$url = 'https://api.imgur.com/3/album/' . $gallery_id;

	my $imgur_auth = 'Client-ID ' . $IMGUR_ID; # Construct the imgur auth header.

	my $ua = LWP::UserAgent->new;

	$ua->agent($USERAGENT);

	$ua->default_header('Authorization' => $imgur_auth);

	my $response = $ua->get($url);

	my $content;

	if($response->is_success){
		$content = $response->decoded_content;
	}else{

        if(!$opt_s){
            print "\nERROR: Could not get $url\nHTTP Response: " . $response->status_line . "\n\n";
        }
        
		open(FAILEDURLS, '>>', $FAILEDURLS) || print "Could not open $FAILEDURLS: $!\n" unless $opt_s && return;
		print FAILEDURLS "$url\n"; # Add the URL to the Failed URLs file if it fails.
		close FAILEDRULS;
		return;
	}

	my $json = JSON::XS->new->decode($content);

	my $album_id = $json->{'data'}->{'id'};

	foreach my $image (@{$json->{'data'}->{'images'}}){ # Loop through the images in the album.

		my $filename = $album_id . '.' . fileparse($image->{'link'}); # Construct the filename in the form: <album ID>.<image ID>.<ext> This ensures that images from the same album will sort together.

		$filename = filename_check($filename); # Check whether the filename exists in the destination. If so, append a pseudo-random string to the new filename.

		if(!$opt_q && !$opt_s){
            print "\tDownloading $image->{'link'}\n";
        }

		my $ua = LWP::UserAgent->new;
		$ua->agent($USERAGENT);

		$ua->default_header('Authorization' => $imgur_auth);

		my $response = $ua->get($image->{'link'});

		my $content;

		if($response->is_success){
			$content = $response->decoded_content;
		}else{
            if(!$opt_s){
                print "\nERROR: Could not get $image->{'link'}\nHTTP Response: " . $response->status_line . "\n\n";
            }
			open(FAILEDURLS, '>>', $FAILEDURLS) || print "Could not open $FAILEDURLS: $!\n" unless $opt_s && next;
			print FAILEDURLS "$image->{'link'}\n";
			close FAILEDRULS;
			next;
		}

		open(IMAGE, '>', $DESTINATION . $DIR_SEPARATOR . $filename) || print "Could not save " . $DESTINATION . $DIR_SEPARATOR . $filename . ": $!\n" unless $opt_s && next;
		binmode IMAGE;
		print IMAGE $content;
		close IMAGE;
	}
}

# get_imgur_image() downloads a single imgur image.
sub get_imgur_image{

	if($IMGUR_ID eq 'disabled'){
		return;
	}

	my $url = shift;

	my @image_ids;

	my($id) = fileparse($url);

	if($id =~ /,/){
		@image_ids = split(',', $id);
	}else{
		push(@image_ids, $id);
	}

	foreach my $image_id (@image_ids){
		$image_id =~ s/(.*)\/?[0-9]$/$1/i;
		$url = 'https://api.imgur.com/3/image/' . $image_id;

		my $imgur_auth = 'Client-ID ' . $IMGUR_ID;

		my $json_ua = LWP::UserAgent->new;

		$json_ua->agent($USERAGENT);

		$json_ua->default_header('Authorization' => $imgur_auth);

		my $json_response = $json_ua->get($url);

		my $json_content;

		if ($json_response->is_success) {
			$json_content = $json_response->decoded_content;
		}else{
            if(!$opt_s){
                print "\nERROR: Could not get $url\nHTTP Response: " . $json_response->status_line . "\n\n";
            }
            
			open(FAILEDURLS, '>>', $FAILEDURLS) || print "Could not open $FAILEDURLS: $!\n" unless $opt_s && return;
			print FAILEDURLS "$url\n";
			close FAILEDRULS;
			return;
		}

		my $json = JSON::XS->new->decode($json_content);

		my $image_link = $json->{'data'}->{'link'};

		my ($fn, $path, $suffix) = fileparse($image_link, @SUFFIXES);

		my $filename = filename_check($fn . $suffix);	

		if(!$opt_q && !$opt_s){
            print "Downloading $image_link\n";
        }

		my $image_ua = LWP::UserAgent->new;
		$image_ua->agent($USERAGENT);

		$image_ua->default_header('Authorization' => $imgur_auth);

		my $image_response = $image_ua->get($image_link);

		my $image_content;

		if($image_response->is_success){
			$image_content = $image_response->decoded_content;
		}else{
            if(!$opt_s){
                print "\nERROR: Could not get $image_link\nHTTP Response: " . $image_response->status_line . "\n\n";
            }

			open(FAILEDURLS, '>>', $FAILEDURLS) || print "Could not open $FAILEDURLS: $!\n" unless $opt_s && return;
			print FAILEDURLS "$image_link\n";
			close FAILEDRULS;
			return;
		}

		open(IMAGE, '>', $DESTINATION . $DIR_SEPARATOR . $filename) || print "Could not save " . $DESTINATION . $DIR_SEPARATOR . $filename . ": $!\n" unless $opt_s && return;
		binmode IMAGE;
		print IMAGE $image_content;
		close IMAGE;
	}
}

# Check for new tumblr likes
sub check_tumblr_likes{
	my $username = shift;
	my $ua = OAuth::Consumer->new(
		oauth_consumer_key => shift,
		oauth_consumer_secret => shift,
		oauth_token => shift,
		oauth_token_secret => shift 
		);

	$ua->agent($USERAGENT);

	my $offset = 0;
	my $limit = 1;

	my $url = "http://api.tumblr.com/v2/user/likes?limit=$limit&offset=$offset";

	my $response = $ua->get($url);

	my $content;

	if ($response->is_success) {
		$content = $response->decoded_content;
	}else{
        if(!$opt_s){
            print "\nERROR: Could not get $url\nHTTP Response: " . $response->status_line . "\n\n";
        }
		return 0;
	}	

	my $json = JSON::XS->new->decode($content);
	
	my $numlikes = $json->{'response'}->{'liked_count'};

	return $numlikes;
}

# If there are new tumblr likes, download them.
sub get_tumblr_likes{
	my $ua = OAuth::Consumer->new(
		oauth_consumer_key => shift,
		oauth_consumer_secret => shift,
		oauth_token => shift,
		oauth_token_secret => shift 
		);

	$ua->agent($USERAGENT);

	my $offset = shift;
	my $limit = shift;

	my $url = "http://api.tumblr.com/v2/user/likes?limit=$limit&offset=$offset";

	my $response = $ua->get($url);

	my $content;

	if($response->is_success){
		$content = $response->decoded_content;
	}else{
        if(!$opt_s){
            print "\nERROR: Could not get $url\nHTTP Response: " . $response->status_line . "\n\n";
        }

        return 0;
	}
	return $content;
}

# Once we have the new tumblr likes, we can download the images in them.
sub download_tumblr_images{
	my $content = shift;
	my $json = JSON::XS->new->decode($content);

	my $likes = \@{$json->{'response'}->{'liked_posts'}}; 

	foreach my $like (@$likes){
		my $photos = \@{$like->{'photos'}};
		foreach my $photo (@$photos){
			my $url = $photo->{'original_size'}->{'url'};
			my $filename = fileparse($url);
            if(!$opt_q && !$opt_s){
                print "Downloading $filename\n";
            }
			$filename = filename_check($filename);

			my $image_ua = LWP::UserAgent->new;
			$image_ua->agent($USERAGENT);

			my $image_response = $image_ua->get($url);

			my $image_content;

			if ($image_response->is_success) {
				$image_content = $image_response->decoded_content;
			}else{
                if(!$opt_s){
                    print "\nERROR: Could not get $url\nHTTP Response: " . $image_response->status_line . "\n\n";
                }
			open(FAILEDURLS, '>>', $FAILEDURLS) || print "Could not open $FAILEDURLS: $!\n" unless $opt_s && next;
			print FAILEDURLS "$url\n";
			close FAILEDRULS;
				next;
			}

			open(IMAGE, '>', $DESTINATION . $DIR_SEPARATOR . $filename) || print "Could not save " . $DESTINATION . $DIR_SEPARATOR . $filename . ": $!\n" unless $opt_s && next;
			binmode IMAGE;
			print IMAGE $image_content;
			close IMAGE;
		}
	}
}

# get_tumblr()
sub get_tumblr{

	foreach my $account (@{$CONF->{'services'}->{'tumblr'}}){
		
		my $username = $account->{'username'};
		my $consumer_key = $account->{'consumer_key'};
		my $consumer_secret = $account->{'consumer_secret'};
		my $token_key = $account->{'token_key'};
		my $token_secret = $account->{'token_secret'};

		if(!$opt_q && !$opt_s){
            print "\nGetting new tumblr likes for $username.\n";
        }

		my $likes_i_have = $TRACK->{'services'}->{'tumblr'}->{$username};

		my $total_likes = check_tumblr_likes($username, $consumer_key, $consumer_secret, $token_key, $token_secret);

        while($total_likes < 0 && my $get_tries < 3){
            print "\nTumblr hiccup: $username account total likes isn't right, trying again.\n\n";
            sleep(2);
            $total_likes = check_tumblr_likes($username, $consumer_key, $consumer_secret, $token_key, $token_secret);
            $get_tries++;
        }
            
		$TRACK->{'services'}->{'tumblr'}->{$username} = $total_likes;

		my $new_likes = $total_likes - $likes_i_have;

		if ($new_likes > 0){
			if(!$opt_q && !$opt_s){
                print "$new_likes new likes to get for $username\n";
            }
			
			my $likes_per_page = 20;
			my $pages = int($new_likes / $likes_per_page);
			my $remainder = $new_likes % $likes_per_page;
			my $offset = 0;

			for( my $page = 1 ; $page<=$pages; $page++){
				download_tumblr_images(get_tumblr_likes($consumer_key, $consumer_secret, $token_key, $token_secret, $offset, $likes_per_page));
				$offset += $likes_per_page;
			}

			if($remainder > 0){
				download_tumblr_images(get_tumblr_likes($consumer_key, $consumer_secret, $token_key, $token_secret, $offset, $remainder));
			}

        my $new_tracking = JSON::XS->new->pretty(1)->encode($TRACK);

        open(TRACKING, '>', $CONF->{'track_file'}) || print "Could not open $CONF->{'track_file'}: $!\n" unless $opt_s && exit;

        print TRACKING $new_tracking;

        close TRACKING;

		}else{
			if(!$opt_q && !$opt_s){
                print "No new likes to get for $username.\n"
            }
		}
	}
}

# Check for new delicious bookmarks.
sub check_delicious_bookmarks{
	my $username = shift;
	my $password = shift;
	my $lastretrieve = shift;

	my($last_ymd, $last_hms) = $lastretrieve =~ /(.*)T(.*)Z/;
	my($last_y, $last_mo, $last_d) = $last_ymd =~ /(.*)-(.*)-(.*)/;
	my($last_h, $last_mi, $last_s) = $last_hms =~ /(.*):(.*):(.*)/;

	my $last = DateTime->new(
		year => $last_y,
		month => $last_mo,
		day => $last_d,
		hour => $last_h,
		minute => $last_mi,
		second => $last_s,
		time_zone => 'UTC'
	);

	my $url = 'https://' . $username . ':' . $password . '@api.del.icio.us/v1/posts/update';

	my $ua = LWP::UserAgent->new;
	$ua->agent($USERAGENT);

	my $response = $ua->get($url);

	my $content; 

	if ($response->is_success){
		$content = $response->decoded_content;
	}else{
        if(!$opt_s){
            print "\nERROR: Could not get $url\nHTTP Response: " . $response->status_line . "\n\n";
        }

		return 0;
	}

	my $xml = new XML::Simple->XMLin($content);

	my($current_ymd, $current_hms) = $xml->{'time'} =~ /(.*)T(.*)Z/;
	my($current_y, $current_mo, $current_d) = $current_ymd =~ /(.*)-(.*)-(.*)/;
	my($current_h, $current_mi, $current_s) = $current_hms =~ /(.*):(.*):(.*)/;

	my $current = DateTime->new(
		year => $current_y,
		month => $current_mo,
		day => $current_d,
		hour => $current_h,
		minute => $current_mi,
		second => $current_s,
		time_zone => 'UTC'
	);

	my $difference = $current->subtract_datetime_absolute($last);

	if ($difference->is_positive()){
		return 1;
	}else{
		return 0;
	}
}

# If there are new delicious bookmarks, download them.
sub get_delicious_bookmarks{
	my $username = shift;
	my $password = shift;
	my $lastretrieve = shift;
	my $url = 'https://' . $username . ':' . $password . '@api.del.icio.us/v1/json/posts/all?&fromdt=' . $lastretrieve;
	my $ua = LWP::UserAgent->new;
	$ua->agent($USERAGENT);
	my $response = $ua->get($url);
	my $content; 
	if($response->is_success){
		$content = $response->decoded_content;
	}else{
        if(!$opt_s){
            print "\nERROR: Could not get $url\nHTTP Response: " . $response->status_line . "\n\n";
        }

		return;
	}
	my $json = JSON::XS->new->decode($content);
	return $json;
}

# Once we have the new delicious bookmarks, we can download the images in them.
sub download_delicious_images{

	my $json = shift;

	foreach my $post (@{$json->{'posts'}}){

		my $url = $post->{'post'}->{'href'};
		my ($fn, $path, $suffix) = fileparse($url, @SUFFIXES);

		if($url =~ /imgur\.com\/a\//i){
			get_imgur_album($url);
		}
		elsif ( $suffix ){
			my $filename = filename_check($fn . $suffix);
			if(!$opt_q && !$opt_s){
                print "Downloading $url\n";
            }

			my $image_ua = LWP::UserAgent->new;
			$image_ua->agent($USERAGENT);

			my $image_response = $image_ua->get($url);

			my $image_content;

			if ($image_response->is_success) {
				$image_content = $image_response->decoded_content;
			}else{
                if(!$opt_s){
                    print "\nERROR: Could not get $url\nHTTP Response: " . $image_response->status_line . "\n\n";
                }

			open(FAILEDURLS, '>>', $FAILEDURLS) || print "Could not open $FAILEDURLS: $!\n" unless $opt_s && next;
			print FAILEDURLS "$url\n";
			close FAILEDRULS;
				next;
			}

			open(IMAGE, '>', $DESTINATION . $DIR_SEPARATOR . $filename) || print "Could not save " . $DESTINATION . $DIR_SEPARATOR . $filename . ": $!\n" unless $opt_s && next;
			binmode IMAGE;
			print IMAGE $image_content;
			close IMAGE;
		}
		elsif($url =~ /imgur\.com\//i){
			get_imgur_image($url);
		}else{
			if(!$opt_q && !$opt_s){
                print "Adding non-image url $url\n";
            }
			add_nonimage_url($url);
		}
	}
}

# get_delicious()
sub get_delicious{
	foreach my $account (@{$CONF->{'services'}->{'delicious'}}){

		my $username = $account->{'username'};
		my $password = $account->{'password'};

		if(!$opt_q && !$opt_s){
            print "\nGetting new delicious bookmarks for $username\n";
        }

		my $lastretrieve = $TRACK->{'services'}->{'delicious'}->{$username};

		my $now = DateTime->now( time_zone => 'UTC' );
		my $ymd = $now->ymd;
		my $hms = $now->hms;
		my $current_time = $ymd . "T" . $hms . "Z";

		$TRACK->{'services'}->{'delicious'}->{$username} = $current_time;

		if(check_delicious_bookmarks($username, $password, $lastretrieve)){
			download_delicious_images(get_delicious_bookmarks($username, $password, $lastretrieve));
		}else{
			if(!$opt_q && !$opt_s){
                print "There are no new delicious bookmarks for $username.\n";
            }
		}

        my $new_tracking = JSON::XS->new->pretty(1)->encode($TRACK);

        open(TRACKING, '>', $CONF->{'track_file'}) || print "Could not open $CONF->{'track_file'}: $!\n" unless $opt_s && exit;

        print TRACKING $new_tracking;

        close TRACKING;
	}
}

# Check for new reddit saved links.
sub check_reddit_saved{
	my $url = shift;
	my $ua = LWP::UserAgent->new;
	$ua->agent($USERAGENT);
	my $response = $ua->get($url);
	my $content; 
	if ($response->is_success){
		$content = $response->decoded_content;
	}else{
        if(!$opt_s){
            print "\nERROR: Could not get $url\nHTTP Response: " . $response->status_line . "\n\n";
        }
	}

	my $json = JSON::XS->new->decode($content);

	my $before = $json->{'data'}->{'children'}->[0]->{'data'}->{'name'};
	
	return($before, $json);
}

# If there are new reddit saved links, download the images.
sub download_reddit_images{
	my $json = shift;
	foreach my $item (@{$json->{'data'}->{'children'}}){

		my $url = $item->{'data'}->{'url'};

		my ($fn, $path, $suffix) = fileparse($url, @SUFFIXES);

		if($url =~ /imgur\.com\/a\//i){
			get_imgur_album($url);
		}
		elsif( $suffix ){
			my $filename = filename_check($fn . $suffix);
			if(!$opt_q && !$opt_s){
                print "Downloading $url\n";
            }

			my $image_ua = LWP::UserAgent->new;
			$image_ua->agent($USERAGENT);

			my $image_response = $image_ua->get($url);

			my $image_content;

			if ($image_response->is_success) {
				$image_content = $image_response->decoded_content;
			}else{
                if(!$opt_s){
                    print "\nERROR: Could not get $url\nHTTP Response: " . $image_response->status_line . "\n\n";
                }
			open(FAILEDURLS, '>>', $FAILEDURLS) || print "Could not open $FAILEDURLS: $!\n" unless $opt_s && next;

			print FAILEDURLS "$url\n";
			close FAILEDRULS;
				next;
			}

			open(IMAGE, '>', $DESTINATION . $DIR_SEPARATOR . $filename) || print "Could not save " . $DESTINATION . $DIR_SEPARATOR . $filename . ": $!\n" unless $opt_s && next;
			binmode IMAGE;
			print IMAGE $image_content;
			close IMAGE;

		}
		elsif($url =~ /imgur\.com\//i){
			get_imgur_image($url);
		}else{
			if(!$opt_q && !$opt_s){
                print "Adding non-image url $url\n";
            }
			add_nonimage_url($url);
		}
	}
}

# get_reddit()
sub get_reddit{

	foreach my $account (@{$CONF->{'services'}->{'reddit'}}){

		my $url = $account->{'rss_url'};
		my $username = $account->{'username'};

		if(!$opt_q && !$opt_s){
            print "\nGetting Reddit saved links for $username.\n";
        }

		my $lastid = $TRACK->{'services'}->{'reddit'}->{$username};
		my $before = $lastid;

		while($before){
			my $fetchurl = $url . '&limit=100&before=' . $before;
			my @results = check_reddit_saved($fetchurl);
			if($results[0]){
				$before = $results[0];
				download_reddit_images($results[1]);
			}
			else{
				if($before eq $lastid){
					if(!$opt_q && !$opt_s){
                        print "No new saved links to get for $username\n";
                    }
					last;
				}
				else{
					$TRACK->{'services'}->{'reddit'}->{$username} = $before;
					$before = '';
				}
			}

            sleep(2); # Don't query the Reddit API too often.
		}

        my $new_tracking = JSON::XS->new->pretty(1)->encode($TRACK);

        open(TRACKING, '>', $CONF->{'track_file'}) || print "Could not open $CONF->{'track_file'}: $!\n" unless $opt_s && exit;

        print TRACKING $new_tracking;

        close TRACKING;
	}
}

# MAIN
getopts('qsrc:h');

if($opt_h){
    HELP_MESSAGE();
    exit;
}

if($opt_c){
    if(-e $opt_c){
        $conf_file = $opt_c;
    }else{
        if(!$opt_s){
            print "Cannot read packrat configuration file $opt_c\n";
        }

        exit;
    }
}

if(!-e $conf_file || $opt_r){
    $CONF = {};
	first_run();
}

# Check the environment to make sure it's sane.
check_env();

# Get tumblr likes.
if($CONF->{'services'}->{'tumblr'}){
	get_tumblr();
}

# Get del.icio.us bookmarks.
if($CONF->{'services'}->{'delicious'}){
	get_delicious();
}

# Get Reddit saved links.
if($CONF->{'services'}->{'reddit'}){
	get_reddit();
}

if($CONF_UPDATE){
	my $new_conf = JSON::XS->new->pretty(1)->encode($CONF);
	open(CONFIGURATION, '>', $conf_file) || print "Cannot write configuration to $conf_file: $!\n" unless $opt_s && exit;
	print CONFIGURATION $new_conf;
	close CONFIGURATION;
}

my $new_tracking = JSON::XS->new->pretty(1)->encode($TRACK);

open(TRACKING, '>', $CONF->{'track_file'}) || print "Could not open $CONF->{'track_file'}: $!\n" unless $opt_s && exit;

print TRACKING $new_tracking;

close TRACKING;

if(!$opt_q && !$opt_s){
    print "\nAll done.\n\n";
}
